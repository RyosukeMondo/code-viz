{
  "id": "snapshot_1765809468589_ijx3uxoiq",
  "approvalId": "approval_1765809468587_lnlta1y1s",
  "approvalTitle": "Tech Steering Document",
  "version": 1,
  "timestamp": "2025-12-15T14:37:48.589Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Technology Stack\n\n## Project Type\n\n**Hybrid Desktop Application**: Cross-platform code analysis and visualization tool built with Tauri v2, combining a high-performance Rust backend for static analysis with a modern React frontend for interactive 3D/2D visualizations. Operates locally on developer machines with optional CLI interface for CI/CD integration.\n\n## Core Technologies\n\n### Primary Languages\n\n- **Rust 1.75+** (Backend/Analysis Engine)\n  - Compiler: rustc with stable channel\n  - Memory safety without garbage collection overhead\n  - Zero-cost abstractions for C/C++ library bindings\n  - Package Manager: Cargo\n  - Build Tools: cargo-watch, cargo-nextest\n\n- **TypeScript 5.0+** (Frontend/Visualization)\n  - Runtime: Node.js 20+ (dev), Browser WebView (prod)\n  - Build Tool: Vite 5+ with HMR\n  - Package Manager: npm/pnpm\n\n### Application Framework\n\n- **Tauri v2**: Rust-based application shell\n  - Lightweight alternative to Electron (~3MB vs 100MB+ bundle)\n  - Security-first IPC with type-safe command system\n  - Native system integration (file watchers, OS APIs)\n  - WebView2 (Windows), WKWebView (macOS), WebKitGTK (Linux)\n\n### Key Dependencies/Libraries\n\n#### Rust Backend (Analysis Core)\n\n- **tree-sitter 0.20+**: Incremental multi-language parser\n  - Generates concrete syntax trees (CST)\n  - Sub-second re-parsing on file edits\n  - Language grammars: TypeScript, JavaScript, Rust, Python, Go\n\n- **stack-graphs 0.13+**: Cross-file semantic analysis\n  - Name resolution and symbol binding\n  - Dead code detection via reachability analysis\n  - Incremental graph updates on file changes\n\n- **git2-rs 0.18+**: Direct Git repository access\n  - libgit2 bindings for high-performance history traversal\n  - Commit graph analysis without subprocess overhead\n  - Diff calculation for churn metrics\n\n- **rayon 1.8+**: Data parallelism\n  - Work-stealing thread pool for file processing\n  - Parallel iterator abstractions\n\n- **notify 6.1+**: File system watcher\n  - Cross-platform inotify/FSEvents/ReadDirectoryChangesW\n  - Real-time codebase monitoring\n\n- **serde 1.0+**: Serialization framework\n  - JSON/Binary serialization for IPC\n  - Zero-copy deserialization with serde_json\n\n- **tauri-specta 2.0+**: Contract-driven IPC\n  - Automatic TypeScript type generation from Rust\n  - Compile-time type safety across language boundaries\n\n- **tracing 0.1+**: Structured logging and telemetry\n  - Async-aware instrumentation\n  - OpenTelemetry integration (feature-gated)\n\n#### React Frontend (Visualization UI)\n\n- **React 18+**: Component-based UI framework\n  - Concurrent rendering for smooth animations\n  - Suspense for lazy-loaded visualizations\n\n- **React Three Fiber (R3F) 8.15+**: WebGL 3D visualization\n  - Declarative Three.js wrapper\n  - React hooks for animation loops\n  - Sub-packages: @react-three/drei, @react-three/postprocessing\n\n- **Three.js 0.160+**: Low-level 3D graphics\n  - InstancedMesh for rendering 100K+ objects\n  - WebGL shaders for color mapping\n  - BVH acceleration (three-mesh-bvh) for raycasting\n\n- **Apache ECharts 5.5+**: 2D data visualization\n  - Canvas-based rendering (non-DOM)\n  - Zoomable treemap with drill-down\n  - Git history timeline charts\n\n- **Zustand 4.4+**: Lightweight state management\n  - No Context API re-render issues\n  - Selector-based subscriptions\n  - Middleware for persistence\n\n- **Tailwind CSS 3.4+**: Utility-first styling\n  - JIT compilation for minimal bundle size\n  - Dark mode support\n\n### Application Architecture\n\n**Layered Hybrid Architecture** with strict separation of concerns:\n\n```\n┌─────────────────────────────────────────────┐\n│         Frontend (React + WebGL)            │\n│  ┌────────────┐  ┌──────────────────────┐   │\n│  │  UI Layer  │  │  Visualization Layer │   │\n│  │  (Tailwind)│  │  (R3F, ECharts)      │   │\n│  └─────┬──────┘  └──────────┬───────────┘   │\n│        │                    │               │\n│        └────────┬───────────┘               │\n│                 │ Type-safe IPC             │\n│         ┌───────▼──────────┐                │\n│         │  Tauri Commands  │                │\n│         │  (Generated TS)  │                │\n└─────────┴──────────────────┴────────────────┘\n                 │ IPC Bridge\n┌─────────────────▼───────────────────────────┐\n│         Backend (Rust Core)                 │\n│  ┌──────────────────────────────────────┐   │\n│  │     Command Handlers (Tauri)         │   │\n│  │     (#[tauri::command] functions)    │   │\n│  └─────────────────┬────────────────────┘   │\n│                    │                        │\n│  ┌─────────────────▼────────────────────┐   │\n│  │      Analysis Engine                 │   │\n│  │  ┌─────────┐  ┌──────────────────┐   │   │\n│  │  │Tree-    │  │ Stack-graphs     │   │   │\n│  │  │sitter   │→ │ (Name Resolution)│   │   │\n│  │  │Parsers  │  └──────────────────┘   │   │\n│  │  └─────────┘                         │   │\n│  │  ┌─────────────────────────────────┐ │   │\n│  │  │ Metrics Calculator (Rayon)      │ │   │\n│  │  │ - Cognitive Complexity          │ │   │\n│  │  │ - LOC, Churn, AI Bloat Index    │ │   │\n│  │  └─────────────────────────────────┘ │   │\n│  └──────────────────────────────────────┘   │\n│                    │                        │\n│  ┌─────────────────▼────────────────────┐   │\n│  │  Git History Manager (git2-rs)      │   │\n│  └──────────────────────────────────────┘   │\n│                    │                        │\n│  ┌─────────────────▼────────────────────┐   │\n│  │  Cache Layer (sled / SQLite)        │   │\n│  │  - Parsed ASTs, Metrics Snapshots   │   │\n│  └──────────────────────────────────────┘   │\n└─────────────────────────────────────────────┘\n```\n\n**Key Architectural Principles:**\n\n1. **SSOT (Single Source of Truth)**: Rust backend defines all data models; TypeScript types auto-generated via tauri-specta\n2. **Contract-Driven**: IPC contracts enforced at compile time, not runtime\n3. **Incremental Processing**: Tree-sitter and stack-graphs minimize re-computation on file changes\n4. **Parallel Execution**: Rayon parallelizes file analysis across CPU cores\n5. **Lazy Visualization**: 3D scenes use LOD (Level of Detail) and culling; 2D charts lazy-load deep nodes\n\n### Data Storage\n\n- **Primary Storage**: Local file system\n  - User repositories analyzed in-place (no copying)\n  - Analysis cache: `.code-viz/cache/` directory (gitignored)\n\n- **Caching**: Hybrid approach\n  - **Hot Cache (In-Memory)**: Recently analyzed files in Rust HashMap/BTreeMap\n  - **Cold Cache (Disk)**: sled embedded database or SQLite\n    - Key: `(repo_path, commit_hash, file_path)`\n    - Value: Compressed bincode-serialized metrics\n\n- **Data Formats**:\n  - **IPC**: JSON (serde_json) for human-readable debugging; MessagePack for large datasets\n  - **Disk Cache**: bincode (binary) with optional zstd compression\n  - **Export**: JSON, CSV, SVG/PNG (visualization snapshots)\n\n### External Integrations\n\n- **APIs**: None (fully offline operation)\n- **Protocols**: File system APIs, Git object database (local)\n- **Optional Features** (feature-gated):\n  - **GitHub API** (future): Fetch CI build metrics, PR comments\n  - **OpenTelemetry**: Export tracing spans to Jaeger/Honeycomb\n\n## Development Environment\n\n### Build & Development Tools\n\n#### Rust Compilation Acceleration (2025 Standard)\n\n**Linker Optimization:**\n- **Primary**: Mold (Linux) - 10-50x faster than GNU ld\n- **macOS**: System linker (Apple's optimized ld) or lld fallback\n- **Windows**: lld (LLVM linker)\n- Configuration: `.cargo/config.toml`\n  ```toml\n  [target.x86_64-unknown-linux-gnu]\n  linker = \"clang\"\n  rustflags = [\"-C\", \"link-arg=-fuse-ld=mold\"]\n  ```\n\n**Compilation Cache:**\n- **sccache**: Shared compilation cache across projects\n  - Environment: `RUSTC_WRAPPER=sccache`\n  - Backend: Local disk (~10GB cache) or S3 for CI\n  - Speedup: 35-60% on incremental builds\n\n**Environment Synchronization:**\n- Problem: rust-analyzer and `tauri dev` use different `MACOSX_DEPLOYMENT_TARGET`, causing double-builds\n- Solution: Sync VSCode settings with tauri.conf.json:\n  ```json\n  // .vscode/settings.json\n  {\n    \"rust-analyzer.cargo.extraEnv\": {\n      \"MACOSX_DEPLOYMENT_TARGET\": \"10.13\"\n    }\n  }\n  ```\n\n#### Task Runner: Just (not Make)\n\n- **Justfile**: Modern command runner with cross-platform compatibility\n  - No tab/space issues\n  - Native Windows PowerShell support\n  - Better error messages than Make\n\n**Example Justfile Recipes:**\n```just\n# Generate TypeScript bindings from Rust types\ncodegen:\n    cargo test --package tauri-plugin --lib -- --nocapture specta\n\n# Development with hot reload\ndev:\n    just codegen\n    tauri dev --features dev-tools\n\n# Production build with optimizations\nrelease:\n    cargo build --release --target x86_64-apple-darwin\n    npm run build\n    tauri build\n\n# Run tests in parallel\ntest:\n    cargo nextest run --all-features\n```\n\n### Terminal Workspace: Zellij\n\n- **Zellij**: Rust-based terminal multiplexer (tmux alternative)\n  - KDL layout files committed to repo\n  - Standard 3-pane layout:\n    - Left: File navigator (strider plugin)\n    - Center: Editor / main terminal\n    - Bottom: Split panes for `cargo run` and `npm run dev`\n    - Right (optional): TUI logger for structured logs\n\n**Layout File** (`.zellij/layout.kdl`):\n```kdl\nlayout {\n    pane split_direction=\"vertical\" {\n        pane size=\"20%\" { command \"strider\"; }\n        pane split_direction=\"horizontal\" {\n            pane size=\"70%\"\n            pane split_direction=\"vertical\" {\n                pane { command \"cargo\"; args \"watch\" \"-x\" \"run\"; }\n                pane { command \"npm\"; args \"run\" \"dev\"; }\n            }\n        }\n    }\n}\n```\n\n### Code Quality Tools\n\n- **Static Analysis**:\n  - **clippy**: Rust linter with `clippy::pedantic` enabled\n  - **cargo-audit**: Security vulnerability scanner\n  - **ESLint + typescript-eslint**: TypeScript linting\n\n- **Formatting**:\n  - **rustfmt**: Rust (edition 2021, 100-char line width)\n  - **Prettier**: TypeScript/JSON/Markdown\n\n- **Testing Frameworks**:\n  - **Rust**: cargo-nextest (faster test runner), insta (snapshot testing)\n  - **React**: Vitest (unit), Playwright (E2E for Tauri WebView)\n  - **Storybook**: Component visual testing\n\n- **Documentation**:\n  - **rustdoc**: API docs with examples\n  - **Docusaurus**: User-facing documentation site\n\n### Version Control & Collaboration\n\n- **VCS**: Git\n- **Branching Strategy**: GitHub Flow (main + feature branches)\n- **Pre-commit Hooks** (husky + cargo-husky):\n  - `cargo fmt --check`\n  - `cargo clippy -- -D warnings`\n  - `npm run lint`\n  - `cargo test --quiet`\n- **Code Review**: GitHub PRs with required CI checks\n\n### Dashboard Development\n\n- **Live Reload**:\n  - Frontend: Vite HMR (Hot Module Replacement)\n  - Backend: cargo-watch auto-restarts on Rust changes\n  - Tauri: WebView survives backend restarts via state persistence\n\n- **Port Management**: Vite dev server on dynamic port (5173+), configurable via env\n\n- **Logging**: tui-logger in Zellij pane for real-time structured log filtering\n\n## Deployment & Distribution\n\n- **Target Platforms**:\n  - macOS 10.13+ (x64, ARM64)\n  - Windows 10+ (x64)\n  - Linux (x64, ARM64) - AppImage + Debian package\n\n- **Distribution Method**:\n  - **GitHub Releases**: Signed binaries + auto-update manifests\n  - **Homebrew** (macOS): `brew install code-viz`\n  - **Future**: Snap (Linux), Chocolatey (Windows)\n\n- **Installation Requirements**:\n  - No external dependencies (Rust and Node.js embedded in binary)\n  - Git installed (for repository analysis)\n\n- **Update Mechanism**: Tauri's built-in updater with signature verification\n\n## Technical Requirements & Constraints\n\n### Performance Requirements\n\n- **Startup Time**: <2 seconds from launch to UI ready\n- **Analysis Latency**:\n  - Incremental re-analysis: <100ms for single file change\n  - Full repository scan: <30 seconds for 100K files (parallelized)\n- **Memory Usage**: <500MB baseline, +1MB per 1K files analyzed\n- **Frame Rate**: 60 FPS for 3D visualization with 50K objects (via InstancedMesh)\n\n### Compatibility Requirements\n\n- **Rust**: MSRV (Minimum Supported Rust Version) 1.75+\n- **Node.js**: 20+ for development\n- **Git**: 2.30+ (for advanced diff algorithms)\n- **GPU**: WebGL 2.0 support (fallback to 2D-only mode if unavailable)\n\n### Security & Compliance\n\n- **Local-Only Processing**: No data leaves the machine\n- **Tauri Security**:\n  - IPC allowlist (only whitelisted commands callable)\n  - CSP (Content Security Policy) enforced\n  - No eval() or inline scripts in WebView\n- **Threat Model**: User-controlled input (local repositories); no network attack surface\n\n### Scalability & Reliability\n\n- **Expected Load**: Single-user desktop app; 1-10 repositories monitored simultaneously\n- **Graceful Degradation**:\n  - If Git history too large (>100K commits), sample every Nth commit\n  - If file count exceeds memory, use disk-backed graph (rocksdb/sled)\n- **Crash Recovery**: Analysis progress checkpointed every 10 seconds; resume on restart\n\n## Technical Decisions & Rationale\n\n### Decision Log\n\n1. **Rust for Analysis Engine (vs Python/Node.js)**\n   - **Rationale**: Tree-sitter and stack-graphs are Rust-native; Python bindings add FFI overhead. Memory safety critical for parsing untrusted codebases.\n   - **Trade-off**: Longer compile times (mitigated by sccache/mold).\n\n2. **Tauri v2 over Electron**\n   - **Rationale**: 97% smaller binary size (3MB vs 100MB), better security model, native performance.\n   - **Trade-off**: Smaller ecosystem than Electron; requires Rust knowledge.\n\n3. **React Three Fiber over Unity/Unreal WebGL Export**\n   - **Rationale**: Lighter runtime, tighter integration with React state, no licensing restrictions.\n   - **Trade-off**: Manual optimization (InstancedMesh, BVH) required for performance.\n\n4. **Stack-graphs over LSP (Language Server Protocol)**\n   - **Rationale**: LSP designed for editor support, not batch analysis. Stack-graphs provide incremental, exportable semantic data.\n   - **Trade-off**: Language coverage limited (need to write grammars).\n\n5. **Type-Safe IPC (tauri-specta) over JSON Schema**\n   - **Rationale**: Compile-time enforcement prevents runtime IPC errors. DX improvement (autocomplete in TS).\n   - **Trade-off**: Requires codegen step (`just codegen`) after Rust changes.\n\n6. **Just over Make**\n   - **Rationale**: Cross-platform (Windows native support), better syntax (no tab/space hell).\n   - **Trade-off**: Team must install Just (but it's Rust-based, one binary).\n\n7. **Apache ECharts over D3.js**\n   - **Rationale**: Canvas rendering 10x faster than SVG for large datasets; treemap built-in.\n   - **Trade-off**: Less flexible than D3; harder to customize animations.\n\n## Known Limitations\n\n- **Language Support**: Tree-sitter grammars required for each language; currently supports TypeScript/JavaScript/Rust/Python. Go/Java/C++ require additional grammar integration.\n\n- **Monorepo Performance**: Workspaces with shared dependencies (npm/yarn) analyzed separately; no cross-workspace dead code detection yet.\n\n- **Dynamic Language Challenges**: Python/JavaScript's dynamic nature limits stack-graphs accuracy (e.g., `eval()`, dynamic imports).\n\n- **3D Rendering on Integrated GPUs**: Intel UHD graphics may struggle with >100K objects; fallback to 2D-only mode recommended.\n\n- **Git LFS**: Large binary files in Git history slow down analysis; recommend excluding via `.code-viz-ignore`.\n\n## AI-Native Development Workflows\n\n### .cursorrules Protocol\n\n**Purpose**: Enforce architectural constraints and coding standards for AI agents (Cursor, GitHub Copilot, Claude).\n\n**Location**: `.cursorrules` (project root)\n\n**Key Directives**:\n```markdown\n# Code-Viz Development Rules\n\n## Technology Stack\n- ALWAYS use tauri-specta for IPC. Raw `invoke()` calls are PROHIBITED.\n- After modifying Rust structs, RUN `just codegen` to regenerate TypeScript types.\n\n## Rust Standards\n- Follow clippy::pedantic warnings.\n- Use thiserror for library errors, anyhow for application errors.\n- ALL public functions must have doc comments with examples.\n\n## React Standards\n- Prefer functional components and hooks over classes.\n- Use Zustand for global state; avoid Context API for performance-critical data.\n- Tailwind CSS for styling; no inline styles.\n\n## Testing\n- Rust: Unit tests for all public functions. Use insta for snapshot tests.\n- React: Storybook stories for all reusable components.\n\n## Before Making Changes\n- READ `LLM.md` for project structure and API contracts.\n- CHECK existing patterns in similar modules before inventing new abstractions.\n```\n\n### LLM.md Context Optimization\n\n**Purpose**: Provide AI agents with project overview without full codebase traversal.\n\n**Generation**:\n```bash\n# Automated via Just recipe\njust generate-llm-context\n# → Runs rustdoc-json + custom script to extract signatures\n```\n\n**Contents**:\n- Public API signatures (no implementation)\n- Module dependency graph\n- Architecture invariants (e.g., \"Never call git2 from UI thread\")\n- Common pitfalls (e.g., \"Tree-sitter nodes invalidated after edit\")\n\n**Usage**: Include in AI prompts:\n```\nContext: @LLM.md\nTask: Add a new metric for \"cyclomatic complexity\" to the analysis engine.\n```\n\n### Documentation as Code\n\n- Each crate (e.g., `crates/analysis/`) has `README.md` with:\n  - **Purpose**: What this crate does (for AI understanding)\n  - **Public API**: Entry points and traits\n  - **Invariants**: Assumptions that must hold (e.g., \"Parsers are !Send\")\n\n- AI agents navigate high-level docs → module docs → function docs (hierarchical context loading).\n\n## Future Technical Enhancements\n\n- **WASM Plugin System**: Allow users to write custom metrics in Rust/C compiled to WASM, sandboxed execution.\n- **GPU Compute Shaders**: Offload complexity calculations to GPU via WebGPU for real-time updates.\n- **Remote Indexing**: Optional cloud-based indexing for teams (with end-to-end encryption).\n- **ML-Based Dead Code Prediction**: Train model on \"code that eventually got deleted\" to predict future dead code.\n",
  "fileStats": {
    "size": 19757,
    "lines": 486,
    "lastModified": "2025-12-15T14:37:42.855Z"
  },
  "comments": []
}