{
  "id": "snapshot_1765811144478_1use2j2zd",
  "approvalId": "approval_1765810798915_mf4dbcvzq",
  "approvalTitle": "MVP Requirements Document (CLI-First Revision)",
  "version": 3,
  "timestamp": "2025-12-15T15:05:44.478Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document - MVP (CLI-First)\n\n## Introduction\n\nThe Code-Viz MVP is a **command-line analysis tool** that provides developers with instant, actionable insights into codebase health through fast analysis and flexible output formats. This CLI-first approach prioritizes:\n\n- **Rapid Iteration**: Sub-second analysis for incremental changes via watch mode\n- **Scriptability**: JSON/CSV output for integration with CI/CD pipelines and custom tooling\n- **Developer Workflow**: Fits naturally into terminal-based development (alongside git, ripgrep, etc.)\n- **Composability**: Output can be piped to other tools or visualized with external viewers\n\nThe MVP enables developers to:\n- **Analyze** any codebase with a single command: `code-viz analyze ./src`\n- **Monitor** changes in real-time: `code-viz watch ./src`\n- **Export** metrics as JSON/CSV for custom dashboards or CI checks\n- **Debug** analysis with verbose logging and structured traces\n\nBy building a robust CLI foundation first, we enable maximum flexibility: developers can integrate Code-Viz into their existing workflows immediately, and GUI layers can be added later as thin clients consuming the CLI's structured output.\n\n## Alignment with Product Vision\n\nThis MVP directly supports the product vision outlined in `product.md`:\n\n- **CLI-First Development** (Product Principle #5): **PRIMARY FOCUS** - Build powerful CLI tool that developers can script, automate, and integrate into their existing terminal workflows\n- **Performance at Scale** (Product Principle #2): Incremental analysis and watch mode enable real-time feedback loops essential for rapid iteration\n- **Actionable Intelligence** (Product Principle #3): JSON output provides raw data that can be consumed by any visualization tool, CI system, or custom script\n- **Visual-First Cognition** (Product Principle #1): **DEFERRED TO GUI LAYER** - CLI outputs structured data; visualization is a separate concern (can use external tools like `jq`, custom dashboards, or future Tauri GUI)\n\nThe MVP establishes the **analysis engine** as the core value - visualization becomes a pluggable consumer of this engine's output.\n\n## Requirements\n\n### Requirement 1: CLI Interface and Command Structure\n\n**User Story:** As a developer, I want to run a simple command to analyze my codebase, so that I can integrate code health checks into my scripts and workflows.\n\n#### Acceptance Criteria\n\n1. WHEN the user runs `code-viz --help` THEN the system SHALL display usage documentation including:\n   - Available commands (analyze, watch, export)\n   - Common options (--exclude, --format, --verbose)\n   - Example invocations\n\n2. WHEN the user runs `code-viz analyze <path>` THEN the system SHALL:\n   - Scan all supported files in `<path>` recursively\n   - Print a text-based summary to stdout (total files, total LOC, largest files)\n   - Exit with code 0 on success, non-zero on error\n\n3. WHEN the user runs `code-viz analyze <path> --format json` THEN the system SHALL:\n   - Output structured JSON to stdout with schema:\n     ```json\n     {\n       \"summary\": { \"total_files\": 1234, \"total_loc\": 56789, ... },\n       \"files\": [\n         { \"path\": \"src/main.rs\", \"loc\": 450, \"functions\": 12, ... }\n       ]\n     }\n     ```\n   - Allow piping to other tools: `code-viz analyze . --format json | jq '.summary.total_loc'`\n\n4. WHEN the user runs `code-viz analyze <path> --exclude \"node_modules/**\"` THEN the system SHALL skip matching paths\n\n5. WHEN the user runs `code-viz analyze <path> --verbose` THEN the system SHALL:\n   - Print structured logs to stderr (JSON format, filterable with `jq`)\n   - Show progress: \"Analyzing 1234/5678 files...\"\n   - Debug mode logs: parser timings, cache hits, file skips\n\n### Requirement 2: Repository Analysis Engine\n\n**User Story:** As a software developer, I want the CLI to analyze my codebase and calculate metrics, so that I can track code health over time and identify problem areas.\n\n#### Acceptance Criteria\n\n1. WHEN analyzing files THEN the system SHALL calculate per-file metrics:\n   - Lines of Code (LOC, excluding comments/blank lines)\n   - File size in bytes\n   - Number of functions/methods\n   - Last modified timestamp\n\n2. WHEN a repository contains 10,000 files THEN the system SHALL complete analysis within 30 seconds on a mid-range laptop\n\n3. WHEN the user runs `code-viz analyze . --format json > metrics.json` THEN the system SHALL produce a valid JSON file that can be:\n   - Committed to version control for historical tracking\n   - Diffed with previous runs: `diff metrics-old.json metrics-new.json`\n   - Queried: `jq '.files | map(select(.loc > 500)) | length' metrics.json` (count files >500 LOC)\n\n4. IF a file cannot be parsed THEN the system SHALL:\n   - Log a warning to stderr with file path and error reason\n   - Continue analyzing other files\n   - NOT fail the entire analysis\n\n5. WHEN analysis completes THEN the system SHALL write a cache file to `.code-viz/cache` to speed up subsequent runs\n\n### Requirement 3: Watch Mode for Real-Time Feedback\n\n**User Story:** As a developer actively writing code, I want the CLI to re-analyze files automatically when I save, so that I can see immediate feedback on how my changes affect code health.\n\n#### Acceptance Criteria\n\n1. WHEN the user runs `code-viz watch <path>` THEN the system SHALL:\n   - Perform initial analysis\n   - Monitor the directory for file changes (create, modify, delete)\n   - Print \"Watching for changes...\" to stderr\n   - Stay running until Ctrl+C\n\n2. WHEN a monitored file is modified THEN the system SHALL:\n   - Re-analyze only the changed file (incremental)\n   - Print updated metrics to stdout within 100ms\n   - Example output: `[2025-12-15 14:30:45] src/main.rs: 450 LOC (+12 from previous)`\n\n3. WHEN the user runs `code-viz watch <path> --format json` THEN the system SHALL:\n   - Print a new JSON object to stdout on each change (newline-delimited JSON stream)\n   - Allow streaming to analysis tools: `code-viz watch . --format json | my-custom-dashboard`\n\n4. WHEN multiple files change rapidly (e.g., git checkout) THEN the system SHALL:\n   - Debounce updates (max 1 update per second)\n   - Batch-analyze all changed files\n\n5. WHEN watch mode encounters an error THEN the system SHALL:\n   - Log error to stderr\n   - Continue watching (don't exit on single-file errors)\n\n### Requirement 4: Multi-Language Support\n\n**User Story:** As a developer working in polyglot codebases, I want Code-Viz to analyze multiple programming languages, so that I can get unified metrics across my entire project.\n\n#### Acceptance Criteria\n\n1. WHEN the user analyzes a repository THEN the system SHALL support:\n   - TypeScript (`.ts`, `.tsx`)\n   - JavaScript (`.js`, `.jsx`)\n   - Rust (`.rs`)\n   - Python (`.py`)\n\n2. WHEN calculating LOC THEN the system SHALL correctly exclude language-specific comments:\n   - Single-line: `//` (JS/TS/Rust), `#` (Python)\n   - Multi-line: `/* */` (JS/TS/Rust), `'''` / `\"\"\"` (Python)\n\n3. WHEN the user runs `code-viz analyze . --format json` THEN the output SHALL include a `language` field for each file:\n   ```json\n   { \"path\": \"src/main.rs\", \"language\": \"rust\", \"loc\": 450 }\n   ```\n\n4. WHEN parsing a file THEN the system SHALL use Tree-sitter grammars for accurate syntax analysis\n\n### Requirement 5: Configuration and Filtering\n\n**User Story:** As a developer, I want to configure exclusion patterns and defaults, so that I don't have to pass the same flags on every invocation.\n\n#### Acceptance Criteria\n\n1. WHEN the user runs `code-viz analyze .` THEN the system SHALL apply default exclusions:\n   - `node_modules/`, `dist/`, `build/`, `out/`, `target/`, `__pycache__/`, `.git/`\n\n2. WHEN a `.code-viz.toml` config file exists in the repository root THEN the system SHALL:\n   - Read exclusion patterns from `[analysis] exclude = [\"**/generated/**\"]`\n   - Read output format preferences: `[output] format = \"json\"`\n   - Allow CLI flags to override config (CLI > config > defaults)\n\n3. WHEN the user runs `code-viz config init` THEN the system SHALL:\n   - Create a `.code-viz.toml` template file\n   - Include commented examples of all configuration options\n\n4. WHEN the user runs `code-viz analyze . --exclude \"**/tests/**\"` THEN that pattern SHALL be merged with config-based exclusions\n\n### Requirement 6: Export and CI/CD Integration\n\n**User Story:** As a developer, I want to export metrics in various formats and fail CI builds based on thresholds, so that I can enforce code quality standards automatically.\n\n#### Acceptance Criteria\n\n1. WHEN the user runs `code-viz analyze . --format csv > metrics.csv` THEN the system SHALL output CSV format:\n   ```\n   path,language,loc,functions,size_bytes\n   src/main.rs,rust,450,12,8192\n   ```\n\n2. WHEN the user runs `code-viz analyze . --threshold loc=500` THEN the system SHALL:\n   - Exit with code 1 if any file exceeds 500 LOC\n   - Print violating files to stderr: `ERROR: src/huge.rs has 756 LOC (limit: 500)`\n   - Enable CI pipeline to fail: `code-viz analyze . --threshold loc=500 || exit 1`\n\n3. WHEN the user runs `code-viz analyze . --format json --output report.json` THEN the system SHALL write to file instead of stdout\n\n4. WHEN the user runs `code-viz diff metrics-old.json metrics-new.json` THEN the system SHALL:\n   - Print a human-readable summary of changes:\n     ```\n     +12 files added\n     -3 files deleted\n     Total LOC: 45,678 → 48,901 (+3,223)\n     Largest growth: src/api.ts (+234 LOC)\n     ```\n\n5. WHEN the user runs `code-viz analyze . --baseline metrics-baseline.json` THEN the system SHALL:\n   - Compare current analysis to baseline\n   - Exit with code 1 if total LOC increased by >10%\n   - Support \"code health ratcheting\" in CI\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Single Responsibility**:\n  - Analysis engine (Rust library crate) is pure: takes paths → returns metrics (no CLI concerns)\n  - CLI binary (separate crate) handles argument parsing, output formatting, process exit codes\n  - Output formatters (JSON, CSV, text) are pluggable modules\n\n- **Testability**:\n  - Analysis engine has zero dependencies on CLI framework (clap)\n  - All core logic unit-tested with snapshot tests (insta crate)\n  - CLI integration tests use temp directories and verify stdout/stderr\n\n- **Modularity**:\n  - Parser module uses trait `LanguageParser` - adding new languages requires zero changes to core engine\n  - Output formatters implement trait `MetricsFormatter` - adding new formats (e.g., Prometheus) is isolated\n  - File watcher abstracted behind `ChangeMonitor` trait\n\n- **Dependency Management**:\n  - CLI crate depends on analysis crate (not vice versa)\n  - Analysis crate has minimal dependencies (tree-sitter, serde, rayon)\n  - No GUI dependencies in MVP (no Tauri, React, Three.js)\n\n### Performance\n\n- **Startup Time**: CLI shall execute `--help` in <50ms (fast enough for shell autocomplete)\n- **Analysis Speed**:\n  - Initial scan: <30 seconds for 100K files (parallelized with rayon)\n  - Incremental update (watch mode): <100ms for single file\n  - Cache hit: <1 second for re-analyzing unchanged repo\n- **Memory Efficiency**:\n  - <100MB baseline\n  - <500MB for 10K files\n  - Stream output (don't buffer entire JSON in memory before printing)\n\n### Developer Experience (Rapid Iteration)\n\n- **Build Speed**:\n  - Incremental Rust builds: <3 seconds with mold linker and sccache\n  - `cargo watch -x run` for auto-recompile on save\n  - Justfile recipes: `just dev` starts watch mode\n\n- **Debug Mode**:\n  - `--verbose` flag enables structured logging (JSON logs to stderr)\n  - `RUST_LOG=debug code-viz analyze .` for detailed tracing\n  - `--profile` flag outputs flame graph data for performance optimization\n\n- **Fast Feedback Loop**:\n  - Developer workflow: `code-viz watch . --verbose` in tmux/zellij pane\n  - Sees analysis results update in <100ms after saving a file\n  - Can pipe watch output to custom scripts for instant alerts\n\n### Security\n\n- **Local-Only**: No network requests; all operations offline\n- **Read-Only**: Only read file system (no writes except `.code-viz/cache`)\n- **Safe Defaults**: Skip symlinks, limit file size (warn on files >10MB)\n\n### Reliability\n\n- **Error Handling**:\n  - Fail fast on invalid arguments (print usage, exit 1)\n  - Fail gracefully on file errors (log, continue)\n  - Structured errors with context: `ERROR: Failed to parse src/main.rs: unexpected token at line 45`\n\n- **Cross-Platform**: CLI must work on macOS, Linux, Windows (use `std::path::PathBuf`, not string manipulation)\n\n### Usability\n\n- **Shell Integration**:\n  - Exit codes follow Unix conventions (0 = success, 1 = error, 2 = usage error)\n  - Respect `NO_COLOR` environment variable\n  - Support shell completion: `code-viz completions bash > /etc/bash_completion.d/code-viz`\n\n- **Documentation**:\n  - `--help` is comprehensive with examples\n  - `man code-viz` (future: auto-generate from help text)\n  - README includes common recipes (CI integration, watch mode, custom scripts)\n\n## Success Criteria\n\nThe MVP is considered successful if:\n\n1. **Functional Completeness**: All 6 requirements implemented and passing acceptance criteria\n2. **Performance Benchmark**: Analyzes Rust compiler repo (~500K LOC) in <10 seconds\n3. **Developer Validation**: 5 beta testers successfully integrate `code-viz` into their workflows (shell aliases, git hooks, CI pipelines) without assistance\n4. **Composability**: Can be composed with standard Unix tools:\n   - `code-viz analyze . --format json | jq '.summary.total_loc'`\n   - `code-viz watch . | grep \"ERROR\"`\n   - `code-viz analyze . --threshold loc=500 && git commit`\n5. **Technical Foundation**: Analysis engine is library-first; GUI can be built as separate binary importing the engine\n\n## Out of Scope for MVP\n\nExplicitly deferred to post-MVP or separate tools:\n\n- ❌ GUI/Desktop Application (Tauri) - Build as separate binary consuming CLI JSON output\n- ❌ Treemap visualization (use external tool like `https://codesee.io` or custom web app)\n- ❌ Dead code detection (stack-graphs) - Requires semantic analysis beyond syntax parsing\n- ❌ Git history analysis - Not needed for \"current state\" health checks\n- ❌ 3D Code City - Visualization layer, not core analysis\n- ❌ AI-specific metrics - Needs more research\n- ❌ Web server mode (`code-viz serve`) - Can be added post-MVP if demand exists\n- ❌ Cognitive complexity - Use simple LOC heuristic for MVP\n\n## MVP Development Approach (Rapid Iteration)\n\n### Phase 1: Core Engine (Week 1)\n- Rust library crate with Tree-sitter integration\n- Parse TypeScript/JavaScript only (defer Rust/Python)\n- Calculate LOC, skip functions count\n- Parallel file scanning with rayon\n- Snapshot tests with insta\n\n### Phase 2: CLI Interface (Week 2)\n- Binary crate with clap for arg parsing\n- `analyze` command with JSON output\n- Default exclusion patterns\n- Exit codes and error handling\n\n### Phase 3: Watch Mode (Week 3)\n- Integrate `notify` crate for file watching\n- Incremental re-analysis\n- Debouncing logic\n- Stream JSON output on changes\n\n### Phase 4: CI/CD Features (Week 4)\n- `--threshold` flag\n- `diff` command\n- CSV output format\n- GitHub Actions example workflow\n\nEach phase is shippable and provides incremental value.\n\n## Assumptions and Dependencies\n\n### Assumptions\n- Users comfortable with CLI tools (target audience: developers)\n- JSON is acceptable output format (can use jq for queries)\n- Visual representation can be built separately (D3.js web app, custom dashboard, future GUI)\n\n### Dependencies\n- **Tree-sitter 0.20+**: Core parsing engine\n- **clap 4.0+**: CLI argument parsing\n- **serde 1.0+**: JSON serialization\n- **notify 6.0+**: File system watching\n- **rayon 1.8+**: Parallel processing\n\n## Risks and Mitigations\n\n| Risk | Impact | Mitigation |\n|------|--------|-----------|\n| Developers expect GUI, reject CLI-only MVP | High | Market validation first: survey target users on CLI vs GUI preference; emphasize JSON output flexibility |\n| Tree-sitter too slow for watch mode | Medium | Implement parse timeout; cache ASTs; provide `--fast` mode that skips detailed parsing |\n| JSON output schema changes break user scripts | Medium | Semantic versioning; `--format json-v1` for stable schema; deprecation warnings |\n| CLI usage too complex | Low | Comprehensive examples in README; GIF demos; shell aliases cheat sheet |\n\n## Future Enhancement: GUI as CLI Consumer\n\nOnce CLI is stable, a GUI (Tauri app) can be built as a **thin client**:\n\n```\n┌─────────────────────┐\n│   Tauri GUI App     │\n│  (Visualization)    │\n└──────────┬──────────┘\n           │ spawns process\n           ▼\n┌─────────────────────┐\n│  code-viz CLI       │\n│  (Analysis Engine)  │\n│  --format json      │\n└─────────────────────┘\n```\n\nThe GUI would:\n- Spawn `code-viz watch . --format json` as subprocess\n- Parse newline-delimited JSON stream\n- Render treemap using React + ECharts\n- Provide file picker UI (instead of CLI path argument)\n\nThis architecture allows:\n- CLI to evolve independently\n- Multiple GUIs (web, desktop, mobile) consuming same CLI\n- Users to choose: terminal-only OR GUI based on preference\n",
  "fileStats": {
    "size": 17293,
    "lines": 385,
    "lastModified": "2025-12-15T14:59:43.520Z"
  },
  "comments": []
}