{
  "id": "snapshot_1765810450199_z9auz9xsx",
  "approvalId": "approval_1765810132909_m77wqh45j",
  "approvalTitle": "MVP Requirements Document",
  "version": 2,
  "timestamp": "2025-12-15T14:54:10.199Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Requirements Document - MVP\n\n## Introduction\n\nThe Code-Viz MVP delivers the foundational capabilities for developers to visualize and understand codebase health in real-time. This minimum viable product focuses on **core analysis and visualization features** that address the immediate pain point: lack of visibility into code volume, complexity, and structure.\n\nThe MVP enables developers to:\n- **See** their codebase as an interactive visual map (treemap)\n- **Understand** which files are large and complex at a glance\n- **Monitor** changes to code health as they develop\n\nBy providing instant visual feedback on code metrics, the MVP creates a foundation for the complete Code-Viz vision while delivering immediate value to early adopters.\n\n## Alignment with Product Vision\n\nThis MVP directly supports the product vision outlined in `product.md`:\n\n- **Visual-First Cognition** (Product Principle #1): Implements the core treemap visualization that lets developers \"see\" code rather than read metrics in tables\n- **Performance at Scale** (Product Principle #2): Establishes the incremental analysis architecture needed for real-time updates\n- **Actionable Intelligence** (Product Principle #3): Provides immediate visual indicators of problematic files (size/complexity heatmap)\n- **CLI-First Development** (Product Principle #5): Desktop app foundation with architecture supporting future CLI interface\n\nThe MVP defers advanced features (dead code detection, Git history time travel, 3D visualizations, AI-specific metrics) to post-MVP releases, focusing resources on proving the core value proposition: **making code health visible**.\n\n## Requirements\n\n### Requirement 1: Repository Analysis\n\n**User Story:** As a software developer, I want to analyze a local codebase and see its structure and metrics, so that I can understand the overall code health at a glance.\n\n#### Acceptance Criteria\n\n1. WHEN the user selects a directory containing source code THEN the system SHALL scan all supported files (TypeScript, JavaScript, Rust, Python) recursively\n2. WHEN analyzing files THEN the system SHALL calculate the following metrics for each file:\n   - Lines of Code (LOC, excluding comments and blank lines)\n   - File size in bytes\n   - Number of functions/methods\n3. WHEN a repository contains more than 10,000 files THEN the system SHALL complete the initial scan within 30 seconds\n4. IF a file cannot be parsed (syntax errors, unsupported language) THEN the system SHALL log a warning and continue processing other files\n5. WHEN analysis completes THEN the system SHALL store results in an in-memory cache for instant UI updates\n\n### Requirement 2: Treemap Visualization\n\n**User Story:** As a developer, I want to see my codebase as an interactive treemap where file sizes are visually proportional, so that I can quickly identify large files that may need refactoring.\n\n#### Acceptance Criteria\n\n1. WHEN analysis completes THEN the system SHALL render a zoomable treemap visualization where:\n   - Each rectangle represents a file\n   - Rectangle area is proportional to Lines of Code (LOC)\n   - Rectangle color indicates file size category (green: <200 LOC, yellow: 200-500 LOC, red: >500 LOC)\n   - Rectangles are grouped by directory structure (nested rectangles for folders)\n\n2. WHEN the user hovers over a rectangle THEN the system SHALL display a tooltip showing:\n   - File name and full path\n   - LOC count\n   - Number of functions\n   - Last modified timestamp\n\n3. WHEN the user clicks on a directory rectangle THEN the system SHALL zoom into that directory, expanding it to fill the viewport (drill-down navigation)\n\n4. WHEN the user clicks the \"back\" or \"breadcrumb\" navigation THEN the system SHALL zoom out to the parent directory level\n\n5. WHEN the treemap contains more than 1,000 rectangles THEN the system SHALL maintain 60 FPS during pan/zoom interactions\n\n### Requirement 3: Real-Time File Monitoring\n\n**User Story:** As a developer actively writing code, I want the visualization to update automatically when I save files, so that I can see the impact of my changes immediately without manual refreshes.\n\n#### Acceptance Criteria\n\n1. WHEN the user opens a repository for analysis THEN the system SHALL start monitoring the directory for file system changes (create, modify, delete)\n\n2. WHEN a monitored file is modified THEN the system SHALL:\n   - Re-parse only the changed file (incremental analysis)\n   - Update metrics for that file within 100ms\n   - Re-render the treemap with updated rectangle sizes/colors\n\n3. WHEN a new file is created in the monitored directory THEN the system SHALL add it to the treemap automatically\n\n4. WHEN a file is deleted THEN the system SHALL remove its rectangle from the treemap\n\n5. IF file system events arrive faster than the system can process (e.g., bulk operations) THEN the system SHALL debounce updates to avoid UI thrashing (max 1 update per second)\n\n### Requirement 4: Desktop Application Shell\n\n**User Story:** As a user, I want a native desktop application that launches quickly and runs reliably on my operating system, so that I can use Code-Viz without browser dependencies.\n\n#### Acceptance Criteria\n\n1. WHEN the application is launched THEN the system SHALL display the main window within 2 seconds\n\n2. WHEN the application starts THEN the system SHALL present a file picker dialog prompting the user to select a repository directory\n\n3. WHEN the user closes the application THEN the system SHALL persist the last opened repository path and restore it on next launch\n\n4. WHEN the application is running THEN it SHALL consume less than 500MB of memory for a repository with 10,000 files\n\n5. WHEN the backend encounters an error (e.g., file access denied) THEN the system SHALL display a user-friendly error dialog (not a crash or blank screen)\n\n### Requirement 5: Multi-Language Support\n\n**User Story:** As a developer working in polyglot codebases, I want Code-Viz to analyze multiple programming languages, so that I can visualize my entire project structure regardless of tech stack.\n\n#### Acceptance Criteria\n\n1. WHEN the user analyzes a repository THEN the system SHALL support parsing the following languages:\n   - TypeScript (`.ts`, `.tsx`)\n   - JavaScript (`.js`, `.jsx`)\n   - Rust (`.rs`)\n   - Python (`.py`)\n\n2. WHEN a file extension is not recognized THEN the system SHALL skip it silently and log it as \"unsupported format\"\n\n3. WHEN calculating LOC THEN the system SHALL correctly identify and exclude language-specific comment syntax:\n   - Single-line: `//` (JS/TS/Rust), `#` (Python)\n   - Multi-line: `/* */` (JS/TS/Rust), `'''` / `\"\"\"` (Python)\n\n4. WHEN parsing a file THEN the system SHALL use language-specific Tree-sitter grammars for accurate syntax analysis\n\n### Requirement 6: Configuration and Filtering\n\n**User Story:** As a developer, I want to exclude certain directories (like `node_modules`, `target`) from analysis, so that the visualization focuses on source code rather than dependencies.\n\n#### Acceptance Criteria\n\n1. WHEN the application starts THEN the system SHALL apply default exclusion patterns:\n   - `node_modules/`, `dist/`, `build/`, `out/`\n   - `target/` (Rust), `__pycache__/` (Python)\n   - `.git/`, `.next/`, `.cache/`\n\n2. WHEN the user opens settings THEN they SHALL be able to add custom exclusion glob patterns (e.g., `**/generated/**`)\n\n3. WHEN exclusion patterns are modified THEN the system SHALL re-analyze the repository and update the visualization\n\n4. WHEN a large directory (>50K files) is encountered THEN the system SHALL warn the user and offer to exclude it\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Single Responsibility Principle**:\n  - Analysis engine (Rust) only handles parsing/metrics calculation\n  - Visualization layer (React) only handles rendering/user interaction\n  - IPC layer (Tauri commands) only handles data transport\n\n- **Modular Design**:\n  - Parser module supports adding new languages via Tree-sitter grammar plugins\n  - Visualization component (Treemap) is decoupled from data source (can render any hierarchical data)\n  - File watcher is abstracted behind a trait, allowing different implementations (notify vs polling)\n\n- **Dependency Management**:\n  - Backend crates do not depend on frontend packages\n  - Frontend only depends on backend via auto-generated TypeScript types (tauri-specta)\n  - Shared data models defined in Rust, never duplicated in TypeScript\n\n- **Clear Interfaces**:\n  - All IPC commands have typed request/response contracts\n  - Metrics are represented as immutable data structures (serde-serializable)\n  - File system operations abstracted behind repository trait\n\n### Performance\n\n- **Startup Time**: Application shall launch and display UI within 2 seconds (cold start)\n- **Analysis Speed**:\n  - Initial scan: <30 seconds for 100K files (parallelized across CPU cores)\n  - Incremental update: <100ms for single file modification\n- **Memory Efficiency**:\n  - Baseline: <200MB when idle\n  - Analysis: <500MB for 10K files, <2GB for 100K files\n  - Treemap rendering: <100MB additional for DOM/Canvas buffers\n- **Frame Rate**: 60 FPS during treemap interactions (pan, zoom, hover) with up to 5K visible rectangles\n\n### Security\n\n- **Local-Only Operation**: No network requests; all data stays on user's machine\n- **File System Access**: Only read access to user-selected directories (no write/execute permissions)\n- **Tauri Security Model**:\n  - IPC allowlist (only explicitly registered commands are callable)\n  - Content Security Policy (CSP) blocks inline scripts and eval()\n  - No arbitrary code execution from user input\n\n### Reliability\n\n- **Error Handling**:\n  - Graceful degradation if a file cannot be parsed (log error, continue analysis)\n  - Recovery from file watcher failures (fall back to manual refresh)\n  - Crash recovery: Application state persisted to disk every 10 seconds\n\n- **Data Integrity**:\n  - Metrics calculations must be deterministic (same file = same metrics)\n  - Cache invalidation on file modification (stale data never displayed)\n\n- **Cross-Platform**: Must run on macOS 10.13+, Windows 10+, Linux (x64)\n\n### Usability\n\n- **Learnability**:\n  - First-time users should understand treemap navigation within 30 seconds\n  - Tooltip explanations for all metrics (hover over metric name shows definition)\n\n- **Responsiveness**:\n  - All user interactions (click, hover) shall provide visual feedback within 16ms (sub-frame)\n  - Long-running operations (initial scan) shall show progress bar with ETA\n\n- **Accessibility**:\n  - Keyboard navigation for treemap (arrow keys to traverse files, Enter to zoom)\n  - High-contrast mode for color-blind users (alternative to green/yellow/red heatmap)\n\n## Success Criteria\n\nThe MVP is considered successful if:\n\n1. **Functional Completeness**: All 6 requirements implemented and passing acceptance criteria\n2. **Performance Benchmark**: Can analyze the Rust compiler codebase (~500K LOC, 5K files) in under 10 seconds on a mid-range laptop (2020 MacBook Pro)\n3. **User Validation**: 5 beta testers can complete the workflow \"open repo → view treemap → identify largest files\" without assistance\n4. **Technical Foundation**: Architecture supports adding dead code detection and Git history features in subsequent releases without major refactoring\n\n## Out of Scope for MVP\n\nThe following features are explicitly deferred to post-MVP releases:\n\n- ❌ Dead code detection (stack-graphs integration)\n- ❌ Git history time travel and commit replay\n- ❌ 3D Code City visualization\n- ❌ AI-specific metrics (AI Bloat Index, Zombie Code Score)\n- ❌ Export to PNG/SVG/CSV\n- ❌ CLI interface (desktop app only for MVP)\n- ❌ Multi-repository comparison\n- ❌ Cloud sync or team collaboration features\n- ❌ Cognitive complexity calculation (use simple LOC-based heuristic for MVP)\n\nThese features are part of the long-term vision but are not required to validate the core value proposition.\n\n## Assumptions and Dependencies\n\n### Assumptions\n- Users have Git installed locally (not used in MVP, but required for future Git history features)\n- Users' repositories fit within available RAM when analyzed (no streaming/chunking for extremely large repos)\n- Users are familiar with file explorers and basic treemap interactions (SpaceSniffer, WinDirStat)\n\n### Dependencies\n- **Tree-sitter**: Required for multi-language parsing; assumes stable API (0.20+)\n- **Tauri v2**: Assumes GA release available with stable IPC system\n- **Apache ECharts**: Required for treemap; assumes treemap chart type is maintained\n- **Operating System**: Assumes access to file system watch APIs (inotify, FSEvents, ReadDirectoryChangesW)\n\n## Risks and Mitigations\n\n| Risk | Impact | Mitigation |\n|------|--------|-----------|\n| Tree-sitter parsing too slow for large files | High | Implement timeout (5s per file); skip unparseable files |\n| Memory usage exceeds limits on large repos | Medium | Add warning when opening repos >100K files; suggest exclusion patterns |\n| Treemap rendering lags with many rectangles | Medium | Implement virtual rendering (only draw visible rectangles); LOD system |\n| File watcher misses rapid changes | Low | Debounce events; provide manual \"refresh\" button as fallback |\n| Cross-platform inconsistencies | Medium | CI testing on all 3 platforms; acceptance tests cover platform-specific edge cases |\n",
  "fileStats": {
    "size": 13379,
    "lines": 257,
    "lastModified": "2025-12-15T14:48:42.840Z"
  },
  "comments": []
}